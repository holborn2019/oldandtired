/*
  stygmorgan - a ryhthm station software

  stygmorgan.midiexport.C  - Exports Sequencer songs to Midi File.
  Copyright (C) 2006 Josep Andreu (Holborn)
  Author: Josep Andreu

  This program is free software; you can redistribute it and/or modify
  it under the terms of version 2 of the GNU General Public License
  as published by the Free Software Foundation.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License (version 2) for more details.

  You should have received a copy of the GNU General Public License
(version2)
  along with this program; if not, write to the Free Software Foundation,
  Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

*/

#include "stygmorgan.h"


void
RMGMO::saveMidiFile(char *filename)
{

int i=0;


   FILE *fs;
   char temp[128];
   
   genmidi = 1;
   generatracks();
   genmidi = 0;
   bzero(temp,sizeof(temp));
   TiempoBase=nStyle.ppq;
   

  if ((fs = fopen (filename, "w")) != NULL)
   {

   sprintf(temp,"MThd%c%c%c%c%c%c%c%c%c%c",0,0,0,6,0,1,0,7,TiempoBase/256,TiempoBase % 256);

   for (i=0; i<14; i++) fputc(temp[i],fs);

   bzero(temp,sizeof(temp));

   sprintf(temp,"MTrk%c%c%c%c",0,0,cdrums / 256,cdrums % 256);
  
   for (i=0; i<8; i++) fputc(temp[i],fs);

   for (i=0; i<cdrums; i++) fputc(drums[i],fs);  

   bzero(temp,sizeof(temp));

   sprintf(temp,"MTrk%c%c%c%c",0,0,cbajo / 256,cbajo % 256);

   for (i=0; i<8; i++) fputc(temp[i],fs);

   for (i=0; i<cbajo; i++) fputc(bajo[i],fs);
  
   bzero(temp,sizeof(temp));

   sprintf(temp,"MTrk%c%c%c%c",0,0,cacc1 / 256,cacc1 % 256);

   for (i=0; i<8; i++) fputc(temp[i],fs);

   for (i=0; i<cacc1; i++) fputc(acc1[i],fs);

   bzero(temp,sizeof(temp));

   sprintf(temp,"MTrk%c%c%c%c",0,0,cacc2 / 256,cacc2 % 256);

   for (i=0; i<8; i++) fputc(temp[i],fs);

   for (i=0; i<cacc2; i++) fputc(acc2[i],fs);

   bzero(temp,sizeof(temp));

   sprintf(temp,"MTrk%c%c%c%c",0,0,cacc3 / 256,cacc3 % 256);

   for (i=0; i<8; i++) fputc(temp[i],fs);

   for (i=0; i<cacc3; i++) fputc(acc3[i],fs);


   bzero(temp,sizeof(temp));

   sprintf(temp,"MTrk%c%c%c%c",0,0,cacc4 / 256,cacc4 % 256);

   for (i=0; i<8; i++) fputc(temp[i],fs);

   for (i=0; i<cacc4; i++) fputc(acc4[i],fs);

   bzero(temp,sizeof(temp));

   sprintf(temp,"MTrk%c%c%c%c",0,0,cacc5 / 256,cacc5 % 256);

   for (i=0; i<8; i++) fputc(temp[i],fs);

   for (i=0; i<cacc5; i++) fputc(acc5[i],fs);


   fclose(fs);
   
  }



};


void
RMGMO::generatracks()
{

 char copyrigth[64];
 
 bzero(copyrigth,sizeof(copyrigth)); 
 
 sprintf(copyrigth,"Generated by %s %s <c> 2006 by Josep Andreu",PACKAGE,VERSION);

 long longtempo = 0;
 int lt1= 0;
 int lt2= 0;
 int lt3= 0;
 int i;
 snd_seq_tick_time_t ktick=0;
 rela=1.0;
 lppq=1;
 rema=0;
 delta=0;
 cas=1;
 cs=0;
 nStyle.har=0; 
 vcompas=0;
 scompas=0;
 vnegra=0;
 onegra=0;
 patrones=0;
 anti=0;
 posanti=0;
   
 char temp[512];
 
 Pendientes = 0;
 memset (PO,0, sizeof PO);

 memset(drums,0, sizeof drums);
 memset(bajo, 0, sizeof bajo);
 memset(acc1, 0, sizeof acc1);
 memset(acc2, 0, sizeof acc2);
 memset(acc3, 0, sizeof acc3);
 memset(acc4, 0, sizeof acc4);
 memset(acc5, 0, sizeof acc5);


 cdrums = 0;
 cbajo = 0;
 cacc1 = 0;
 cacc2 = 0;
 cacc3 = 0;
 cacc4 = 0;
 cacc5 = 0;

 deltadrums=0;
 deltabajo=0;
 deltaacc1=0;
 deltaacc2=0;
 deltaacc3=0;
 deltaacc4=0;
 deltaacc5=0;
 
 stdrums=0;
 stbajo=0;
 stacc1=0;
 stacc2=0;
 stacc3=0;
 stacc4=0;
 stacc5=0;
  
 
longtempo = (long) 6e7 / SongF.bpm;


lt1 = longtempo / 65536;
lt2 = (longtempo % 65536) / 256;
lt3 = (longtempo % 65536) % 256;

Estilo=S[cas].style;
readstyle(Estilo);
PonAjusta();
bpm=SongF.bpm;
if (SongF.MasterT)BuscaTempo();
calctempo(bpm);
seqbuscacs(S[cas].pattern,0);
Variacion=S[cas].pattern;
mirapc(Variacion);
cs=0;
ptick=0;
BuscaSi();
SNomi=nStyle.nominador;

MiraAcorde(cas,1);

bzero(temp,sizeof(temp));
sprintf(temp,"%c%c%c%c%s%c%c%c%cDrums%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c",0,255,2,(int)strlen(copyrigth),copyrigth,0,255,3,5,0,255,81,3,lt1,lt2,lt3,0,255,88,4,SNomi,nStyle.denominator,nStyle.cpq,8);

int newsize=24 + 4 + (int) strlen(copyrigth); 

for (i=0; i<newsize; i++) drums[i] = temp[i];
cdrums += newsize;

bzero(temp,sizeof(temp));
sprintf(temp,"%c%c%c%cBass",0,255,3,4);
for (i=0; i<8; i++) bajo[i] = temp[i];
cbajo += 8;

bzero(temp,sizeof(temp));
sprintf(temp,"%c%c%c%cAcc1",0,255,3,4);
for (i=0; i<8; i++) acc1[i] = temp[i];
cacc1 += 8;

bzero(temp,sizeof(temp));
sprintf(temp,"%c%c%c%cAcc2",0,255,3,4);
for (i=0; i<8; i++) acc2[i] = temp[i];
cacc2 += 8;

bzero(temp,sizeof(temp));
sprintf(temp,"%c%c%c%cAcc3",0,255,3,4);
for (i=0; i<8; i++) acc3[i] = temp[i];
cacc3 += 8;


bzero(temp,sizeof(temp));
sprintf(temp,"%c%c%c%cAcc4",0,255,3,4);
for (i=0; i<8; i++) acc4[i] = temp[i];
cacc4 += 8;

bzero(temp,sizeof(temp));
sprintf(temp,"%c%c%c%cAcc5",0,255,3,4);
for (i=0; i<8; i++) acc5[i] = temp[i];
cacc5 += 8;

cambiopat(0);

BuscaRepes();


while(1)
{
  
ptick=ktick-(longi*patrones)-rema;
negra=((ptick/nunegra) % divisor) + 1;
vcompas = (ptick / longic);

if (negra != vnegra)
{
vnegra=negra;

if (vnegra==1)
{
 scompas++;
 if (scompas > 1) cas++;

 if(S[cas].fin) break; 

 cas=mirasaltos(cas);

 if ((S[cas].style !=Estilo) && (S[cas].style !=0))
 {
   Estilo=S[cas].style;
   readstyle(Estilo);
   seqbuscacs(S[cas].pattern,ktick);
   Variacion=S[cas].pattern;
   mirapc(Variacion);
   cs=0;
   ptick=0;
   BuscaSi();
   PonNotesOff(0,0);
   cambiopat(0);
   calctempo(bpm);
   PonerTempoMidiFile();
  } 
 
 if ((S[cas].pattern !=Variacion) && (S[cas].pattern !=0))
  {
    seqbuscacs(S[cas].pattern,ktick);
    Variacion=S[cas].pattern;
    mirapc(Variacion);
    cs=0;
    ptick=0;
    BuscaSi();
    PonNotesOff(0,0);
    cambiopat(0);
    
  }

ptick=ktick-(longi * patrones)- rema;
               
                              
}

     
if ((anti) && ((vnegra==1) || (vnegra==3)))
{
 anti=0;
 posanti=0;
}
  
if ((vnegra==2) || (vnegra==4)) MiraAnti(vnegra);
  
MiraAcorde(0,vnegra);

if (SongF.MasterT) MiraCambioTempoM(cas,vnegra);

}
  
if (ptick >= longi)
    {
      patrones++;
      cs=0;
      ptick=0;
    }

parsetracks();
ktick++;
}
  


PonNotesOff(1,0);

bzero(temp,sizeof(temp));
sprintf(temp,"%c%c%c%c",0,255,47,0);
for (i=cdrums; i<cdrums+4; i++) drums[i]=temp[i-cdrums];
cdrums +=4;

bzero(temp,sizeof(temp));
sprintf(temp,"%c%c%c%c",0,255,47,0);
for (i=cbajo; i<cbajo+4; i++) bajo[i]=temp[i-cbajo];
cbajo +=4;

bzero(temp,sizeof(temp));
sprintf(temp,"%c%c%c%c",0,255,47,0);
for (i=cacc1; i<cacc1+4; i++) acc1[i]=temp[i-cacc1];
cacc1 +=4;

bzero(temp,sizeof(temp));
sprintf(temp,"%c%c%c%c",0,255,47,0);
for (i=cacc2; i<cacc2+4; i++) acc2[i]=temp[i-cacc2];
cacc2 +=4;

bzero(temp,sizeof(temp));
sprintf(temp,"%c%c%c%c",0,255,47,0);
for (i=cacc3; i<cacc3+4; i++) acc3[i]=temp[i-cacc3];
cacc3 +=4;


bzero(temp,sizeof(temp));
sprintf(temp,"%c%c%c%c",0,255,47,0);
for (i=cacc4; i<cacc4+4; i++) acc4[i]=temp[i-cacc4];
cacc4 +=4;

bzero(temp,sizeof(temp));
sprintf(temp,"%c%c%c%c",0,255,47,0);
for (i=cacc5; i<cacc5+4; i++) acc5[i]=temp[i-cacc5];
cacc5 +=4;


Estilo=S[1].style;
readstyle(Estilo);
set_tempo();


};



void 
RMGMO::MiraCambioTempoM(int tcompas,int neg)
{

int i;

for (i=1; i<200; i++)
{ 
  if (SongF.TemT[i].bar == 0) break;
  if ((SongF.TemT[i].bar == tcompas) && (SongF.TemT[i].black == neg))

       {  
            calctempo(SongF.TemT[i].tempo);
            PonerTempoMidiFile();
            break;
        }
}
};



void
RMGMO::parsetracks()
{
 
 int ncanal;
 int lanota;


   
   while(PEG[Variacion][cs].tipo==0) cs++;
   
   while((PEG[Variacion][cs].tipo < 1) || ( PEG[Variacion][cs].tipo > 5))
   {
   printf("Ignoring Event %d \n",PEG[Variacion][cs].tipo); 
   cs++;
   }
   
   
   while (( PEG[Variacion][cs].tick <= ptick) && (cs < nStyle.Pattern[Variacion].eventos))

    {
     PonNotesOff(0,PEG[Variacion][cs].tick);
     if ((anti !=0 ) && (PEG[Variacion][cs].tick >= posanti)) CheckAnti();

     if (pc[PEG[Variacion][cs].canal])
        {
             ncanal = pcp[PEG[Variacion][cs].canal];
             if (PEG[Variacion][cs].tipo==2)
                   {
                    lanota=miranota(PEG[Variacion][cs].nota,PEG[Variacion][cs].canal);
                    
                   }
             else lanota=PEG[Variacion][cs].nota;
             
         Ponlo(PEG[Variacion][cs].tipo, PEG[Variacion][cs].tick,lanota,ncanal,PEG[Variacion][cs].velocity,PEG[Variacion][cs].length);  
        }

          
        cs++;

    }



};



void
RMGMO::cambiopat(unsigned int sktick)
{

int i;

for(i=9; i<=15; i++)
{
Ponlo(3, sktick, 0, i,nStyle.Pattern[Variacion].CM[i].bMSB,0);
Ponlo(4, sktick, nStyle.Pattern[Variacion].CM[i].program, i, 0 ,0);
Ponlo(3, sktick, 7, i,nStyle.Pattern[Variacion].CM[i].vol,0);
Ponlo(3, sktick, 10, i,nStyle.Pattern[Variacion].CM[i].pan,0);
Ponlo(3, sktick, 91, i,nStyle.Pattern[Variacion].CM[i].reverb,0);
Ponlo(3, sktick, 93, i,nStyle.Pattern[Variacion].CM[i].chorus,0);
}


};




void
RMGMO::PonNotesOff(int force, snd_seq_tick_time_t gtick)
{
int i;
int actu=0;

if (Pendientes==0) return;

gtick= gtick + ( patrones * longi ) + rema;

         for(i=0; i<Pendientes; i++)
         {
           
           if (((PO[i].delta <= gtick) && (PO[i].estado==1)) || (force==1))    
            {
              actu=1;
              PO[i].estado = 0;
              Ponlo(1,PO[i].delta,PO[i].nota,PO[i].canal, 0,0);
            }
         }
         if (actu) ActuPen();

};


void
RMGMO::ActuPen()

{

 int i;

bzero(POAC, sizeof(POAC));
Pendientes = 0;
for (i=0; i<=78; i++)

{
  if (PO[i].estado == 1)
  {

  POAC[Pendientes]=PO[i];
  Pendientes++;
  }
}

bzero(PO,sizeof(PO));
for (i=0; i<Pendientes; i++) PO[i]=POAC[i];

};


void
RMGMO::Ponlo(int tipo,snd_seq_tick_time_t gtick, int gnota, int canal, int gvelo, int glen) 
{

char temp[64];
int sta=0;
char *pepe=0;
int  *conta=0;
int  *elst=0;
int  *delta=0;
long lala=0;



switch(canal)
       {
        case 9:
        pepe=drums;      
        conta=&cdrums;
        elst=&stdrums;
        delta=&deltadrums;
        break;
        case 10:
        pepe=bajo;      
        conta=&cbajo;
        elst=&stbajo;
        delta=&deltabajo;
        break;
       
        case 11:
        pepe=acc1;      
        conta=&cacc1;
        elst=&stacc1;
        delta=&deltaacc1;
        break;
       
        case 12:
        pepe=acc2;      
        conta=&cacc2;
        elst=&stacc2;
        delta=&deltaacc2;
        break;
       
        case 13:
        pepe=acc3;      
        conta=&cacc3;
        elst=&stacc3;
        delta=&deltaacc3;
        break;
       
        case 14:
        pepe=acc4;      
        conta=&cacc4;
        elst=&stacc4;
        delta=&deltaacc4;
        break;
       
        case 15:
        pepe=acc5;      
        conta=&cacc5;
        elst=&stacc5;
        delta=&deltaacc5;
        break;
        
        default:
        return;
       
       }


        switch(tipo)
        {   
          case 1:
          sta=0x90+canal;
          break;
          case 2:
          sta=0x90+canal;
          break;
          case 3:
          sta=0xB0+canal;
          break;
          case 4:
          sta=0xC0+canal;
          break;
          case 5:
          sta=0xE0+canal;
          break; 
          default:
          return;
          ;
        }


if (tipo != 1 ) gtick = gtick + ( patrones * longi ) + rema;


lala=calculadelta((int)(gtick-*delta));

if (lala < 0 ) lala = 0;

*delta=gtick;


bzero(temp,sizeof(temp));
       while(1)
        {
           bzero(temp,sizeof(temp));
           sprintf(temp,"%c",(int)lala);
           pepe[*conta]=temp[0];
           *conta +=1;
           if (lala & 0x80) lala >>= 8;
           else break;
        }                                                                                        




bzero(temp,sizeof(temp));

if (*elst != sta)
{
 *elst=sta;
 sprintf(temp,"%c",sta);
 pepe[*conta] = temp[0];
 *conta +=1;
} 


bzero(temp,sizeof(temp));


switch(tipo)

  {
  case 1:
     sprintf(temp,"%c%c",gnota,gvelo);
     pepe[*conta]=temp[0]; pepe[*conta+1] = temp[1];
     *conta +=2;
     break;       
  case 2:
     sprintf(temp,"%c%c",gnota,gvelo);
     pepe[*conta]=temp[0]; pepe[*conta+1] = temp[1];
     *conta +=2;
     ponPendientes(gnota,sta-0x90,gtick+glen);
     break;
  case 3: 
     sprintf(temp,"%c%c",gnota,gvelo);
     pepe[*conta]=temp[0]; pepe[*conta+1] =temp[1];
     *conta +=2;
     break;
  case 4:
     sprintf(temp,"%c",gnota);
     pepe[*conta]=temp[0];
     *conta +=1;
     break;
   case 5:
     sprintf(temp,"%c%c",(gnota + 0x2000) & 0x7f,((gnota + 0x2000) >> 7) &0x7f);
     pepe[*conta]=temp[0]; pepe[*conta+1] =temp[1];
     *conta +=2;
     break;
       
   }


};

void
RMGMO::ponPendientes(int gnota,int gcanal,snd_seq_tick_time_t gtick)
{

int k=0;
int i;

while ((PO[k].estado==1) && (PO[k].delta <= gtick))
{
  k++;
}

for (i=Pendientes; i>=k; i--)  PO[i+1]=PO[i];

PO[k].estado=1;
PO[k].nota=gnota;
PO[k].canal=gcanal;
PO[k].delta=gtick;
Pendientes++;

};


long
RMGMO::calculadelta(int value)
{

unsigned long buffer;
unsigned long value1;

value1 = (long) value;

        buffer = value1 & 0x7f;
        while ( (value1 >>= 7) )
           {
             buffer <<= 8;
             buffer |= ((value1 & 0x7F) | 0x80);
           }

return(buffer);
                                                                          
                                                                          
                                                                          
};


void
RMGMO::seqbuscacs(int siguiente,unsigned int ktick)
{

unsigned int nlongi=nStyle.ppq * nStyle.nominador * nStyle.Pattern[siguiente].bars;

if (nlongi != 0)
{
  patrones=ktick/nlongi;
  rema=ktick % nlongi;
}
};


          



void
RMGMO::PonNotesOffChannel(int canal, snd_seq_tick_time_t gtick)
{
int i;
int actu=0;


if (Pendientes==0) return;



gtick= gtick + ( patrones * longi ) + rema;

         for(i=0; i<Pendientes; i++)
         {
           
           if ((PO[i].canal == canal) && (PO[i].estado==1))    
            {
              actu=1;
              PO[i].estado = 0;
              Ponlo(1,gtick,PO[i].nota,PO[i].canal, 0,0);
            }
         }
         if (actu) ActuPen();

};



void
RMGMO::PonerTempoMidiFile()
{


char temp[32];
long longtempo;
int j;
int lt1;
int lt2;
int lt3;


            longtempo = (long) 6e7 / bpm;
            longtempo = (long) (longtempo * rela);
            stdrums=255;
            lt1 = longtempo / 65536;
            lt2 = (longtempo % 65536) / 256;
            lt3 = (longtempo % 65536) % 256;
            bzero(temp,sizeof(temp));
            sprintf(temp,"%c%c%c%c%c%c%c",0,255,81,3,lt1,lt2,lt3);
            for (j=cdrums; j<cdrums+7; j++) drums[j] = temp[j-cdrums];
            cdrums += 7;
            
};


void 
RMGMO::calctempo(int NewTempo)
{

  if (lppq == 1) lppq=nStyle.ppq;
  if (nStyle.ppq != lppq)
    {
     rela= (double)((double) rela * (double)lppq / (double) nStyle.ppq);
     lppq=nStyle.ppq;
    }
          

bpm=NewTempo;

}









